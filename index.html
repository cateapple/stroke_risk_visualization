<html>
    <head>
        <meta charset="UTF-8">
        <title>Stroke risk factor visualizations</title>
        <link rel="stylesheet" type="text/css" href="style.css">
        <script src="https:d3js.org/d3.v6.min.js"></script>
    </head>
    <body>
        <h1>Prevalence in strokes for some risk factors</h1>
        <h3>Catherine Appleby (caa96), Esuvat Bomani (ekb72), Mia Bravo (mvb43)</h3>

        <p></p>
            <svg id="lifefactors" height="750" width="1000"></svg>

            <script>

            const svg = d3.select("svg#lifefactors");

            const width = svg.attr("width");
            const height = svg.attr("height");
            const margins = {"top": 50, "right": 20, "bottom": 100, "left": 150};

            const chartWidth = width - margins.left - margins.right;
            const chartHeight = height - margins.top - margins.bottom;

            let annotated = svg.append("g");
            let chartArea = svg.append("g")
                            .attr("transform","translate("+margins.left+","+margins.top+")");

            var lifedata;
            d3.json("life_factors.json", d3.autoType).then((data) => {
                lifedata = data;
                //Make bar scales
                // x is stroke or not - 0 or 1
                //y scale is the number of bars we're making evenly distributed over the area of the chart in groups by category

                let Lgroups = Array.from(new Set(Object.values(data).map(d => d.category)));
                let Lsubgroups = Array.from(new Set(Object.values(data).map(d => d.subcategory)));

                let xScale = d3.scaleLinear().domain([0,5]).range([0, chartWidth]);
                let yScale = d3.scaleBand().domain(Lgroups).range([chartHeight, 0]).padding([0.01]);
                //let ySubgroupL = d3.scaleBand().domain(Lsubgroups)
                                //  .range([0, yScale.bandwidth()])
                                  //.padding([0.01]);
                function findySubgroup(d){
                    let sg = findSubgroups(d.category);
                    let ySubgroupL = d3.scaleBand().domain(sg)
                                  .range([0, yScale.bandwidth()])
                                  .padding([0.01]);
                    return ySubgroupL(d.subcategory);
                }
                function findSubgroups(category){
                    return Array.from(new Set(Object.values(data).map(function(d){
                        if (category == d.category){return d.subcategory}})));

                }
                function findBandwidth(d){
                    let sg = findSubgroups(d.category);
                    let bandwidth = d3.scaleBand().domain(sg)
                                  .range([0, yScale.bandwidth()])
                                  .padding([0.05]).bandwidth();
                    return bandwidth;
                }

                //conditional color scales - 3 main categories -

                function colorGiver(d){
                    let cat = String(d.category).charAt(0);
                    let sub = String(d.subcategory).charAt(0);
                    let intensity = {P: .2, S: .4, G: .6, c: .8, N: .8, Y: 0.5, U: 0.5, R: .8}
                    if(cat == "R"){
                        console.log(sub)
                        return d3.interpolateGreens(intensity[sub]);
                    }else if(cat == "e"){
                        return d3.interpolateBlues(intensity[sub]);
                    }else{
                        return d3.interpolatePurples(intensity[sub]);
                    }

                }

                //axes append
                let leftAxis = d3.axisLeft(yScale)
                    .tickFormat( tick => tick.charAt(0).toUpperCase() + tick.slice(1).replace(/_/g, " "));

                annotated.append("g").attr("class", "y axis")
                                        .attr("transform", "translate("+(margins.left)+","+(margins.top)+")")
                                        .call(leftAxis);
                //leftAxis.selectAll("text").attr("transform", "rotate(-90)");

                let bottomAxis = d3.axisBottom(xScale);
                let bottomGridLines = d3.axisBottom(xScale).tickFormat("").tickSize(-chartHeight);
                annotated.append("g").attr("class", "x axis")
                                        .attr("transform", "translate("+(margins.left)+","+(margins.top + chartHeight)+")")
                                        .call(bottomAxis);
                annotated.append("g").attr("class", "x gridlines")
                                        .attr("transform", "translate("+(margins.left)+","+(margins.top + chartHeight)+")")
                                        .call(bottomGridLines);

                //append to chart
                const groupEnterL = chartArea.selectAll("g").data(Lgroups)
                     .enter()
                     .append("g")
                     .attr("transform", d => `translate(0, ${yScale(d)})`)
                     .selectAll("rect")
                     .data(d => Object.values(lifedata).filter(e => e.category === d))
                     .enter();


                groupEnterL.append("rect")
                     .lower()
                     .attr("x", xScale(0))
                     .attr("y", d => findySubgroup(d))
                     .attr("width", d => xScale(d.percentage))
                     .attr("height", d => findBandwidth(d))
                     .attr("fill", d => colorGiver(d));

                groupEnterL.append("text")
                    .text(d => d.subcategory+": "+d.percentage.toFixed(2)+"%")
                    .attr("x", 10)
                    .attr("y", d => findySubgroup(d) + findBandwidth(d)/2 + 7)
                    .attr("fill", "black");

                svg.append("text")
                   .text("Life Factors")
                   .attr("transform", `rotate(270,50,${height/2})`)
                   .attr("text-anchor", "middle")
                   .attr("x", 50)
                   .attr("y", height/2)

                svg.append("text")
                  .text("Percentage of Strokes")
                  .attr("x", width/2)
                  .attr("y", 700)

            });

            </script>

          <svg id="healthfactors" height="900" width="1000"></svg>
          <script>
              //graph area for health factors graph
              const svghealth = d3.select("svg#healthfactors");

              const widthH = svghealth.attr("width");
              const heightH = svghealth.attr("height");

              const marginsH = {"top": 50, "right": 20, "bottom": 100, "left": 150};

              const chartWidthH = widthH - marginsH.left - marginsH.right;
              const chartHeightH = heightH - marginsH.top - marginsH.bottom;

              let annotations = svghealth.append("g");
              let chart = svghealth.append("g").attr("transform","translate("+marginsH.left+","+marginsH.top+")");

              d3.json("health_factors.json", d3.autoType).then((data) => {
                console.log(Object.values(data));

                let groups = Array.from(new Set(Object.values(data).map(d => d.risk_factor)));
                let subgroups = Array.from(new Set(Object.values(data).map(d => d.gender))).slice(0,2);

                let xScaleH = d3.scaleLinear().domain([0,20]).range([0, chartWidthH]);
                let yScaleH = d3.scaleBand().domain(groups).range([chartHeightH, 0]).padding([0.05]);
                let ySubgroup = d3.scaleBand()
                                  .domain(subgroups)
                                  .range([0, yScaleH.bandwidth()])
                                  .padding([0.03]);

                let bottomAxisH = d3.axisBottom(xScaleH);
                let bottomGridLinesH = d3.axisBottom(xScaleH).tickFormat("").tickSize(-chartHeightH);
                annotations.append("g").attr("class", "x axis")
                                       .attr("transform", "translate("+(marginsH.left)+","+(marginsH.top + chartHeightH)+")")
                                       .raise()
                                       .call(bottomAxisH);
                annotations.append("g").attr("class", "gridlines")
                                       .attr("transform", "translate("+(marginsH.left)+","+(marginsH.top + chartHeightH)+")")
                                       .call(bottomGridLinesH);

                let leftAxisH = d3.axisLeft(yScaleH).tickFormat( tick => tick.charAt(0).toUpperCase() + tick.slice(1).replace(/_/g, " "));
                annotations.append("g").attr("class", "y axis")
                                       .attr("transform", "translate("+(marginsH.left)+","+(marginsH.top) +")")
                                       .raise()
                                       .call(leftAxisH);

                const groupEnter = chart.selectAll("g").data(groups)
                     .enter()
                     .append("g")
                     .attr("transform", d => `translate(0, ${yScaleH(d)})`)
                     .selectAll("rect")
                     .data(d => Object.values(data).filter(e => e.risk_factor === d))
                     .enter()

                groupEnter.append("rect")
                     .lower()
                     .attr("x", xScaleH(0))
                     .attr("y", d => ySubgroup(d.gender))
                     .attr("width", d => xScaleH(d.percentage))
                     .attr("height", d => ySubgroup.bandwidth())
                     .attr("fill", d => {
                                   if(d.gender === "Male"){
                                     return d3.interpolateBlues(0.8);
                                   }
                                   if(d.gender === "Female"){
                                     return d3.interpolateReds(0.75);
                                   }
                                 }
                           )

                groupEnter.append("text")
                          .text(d => d.percentage.toFixed(2)+"%")
                          .attr("x", 10)
                          .attr("y", d => ySubgroup(d.gender) + ySubgroup.bandwidth()/2 + 7)
                          .attr("fill", "white")


                svghealth.append("text")
                         .text("Health Factors")
                         .attr("transform", `rotate(270,50,${heightH/2})`)
                         .attr("text-anchor", "middle")
                         .attr("x", 50)
                         .attr("y", heightH/2)

                svghealth.append("text")
                        .text("Percentage of Strokes")
                        .attr("x", widthH/2)
                        .attr("y", 850)

                svghealth.append("circle").attr("cx",900).attr("cy",850).attr("r", 8).style("fill", d3.interpolateBlues(0.8))
                svghealth.append("circle").attr("cx",900).attr("cy",880).attr("r", 8).style("fill", d3.interpolateReds(0.75))
                svghealth.append("text").attr("x", 920).attr("y", 850).text("Male").style("font-size", "15px").attr("alignment-baseline","middle")
                svghealth.append("text").attr("x", 920).attr("y", 880).text("Female").style("font-size", "15px").attr("alignment-baseline","middle")


              });
        </script>
    </body>
</html>
